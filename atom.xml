<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fine_974&#39;s Blog</title>
  
  <subtitle>珂学是第一生产力</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-02-28T09:47:45.070Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Fine_974</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode75 题解系列（一）数组 / 字符串篇：9 道高频题解与心得</title>
    <link href="http://example.com/2025/02/28/leetcode75/"/>
    <id>http://example.com/2025/02/28/leetcode75/</id>
    <published>2025-02-28T07:08:24.000Z</published>
    <updated>2025-02-28T09:47:45.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>LeetCode75 是面向算法面试的经典题库，涵盖高频考点与核心思想。本文将针对「数组 / 字符串」专题的 9 道题目，提供简洁清晰的题解思路、代码实现与刷题心得，助你快速掌握解题框架。</p><span id="more"></span><hr><h2 id="一、题目分类与核心技巧"><a href="#一、题目分类与核心技巧" class="headerlink" title="一、题目分类与核心技巧"></a><strong>一、题目分类与核心技巧</strong></h2><p>数组 / 字符串篇共 <strong>9 道题目</strong>，覆盖以下分类（按出现频率排序）：</p><ol><li><strong>双指针</strong>（5题）</li><li><strong>贪心算法</strong>（2题）</li><li><strong>数学推导</strong>（1题）</li><li><strong>前缀和</strong>（1题）</li><li><strong>数组操作</strong>（高频基础题型）</li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">题目名称</th><th style="text-align:left">题号</th><th style="text-align:left">核心技巧</th><th style="text-align:left">关联标签</th></tr></thead><tbody><tr><td style="text-align:left">交替合并字符串</td><td style="text-align:left">1768</td><td style="text-align:left">双指针遍历合并</td><td style="text-align:left">字符串、双指针</td></tr><tr><td style="text-align:left">字符串的最大公因子</td><td style="text-align:left">1071</td><td style="text-align:left">数学（最大公约数）</td><td style="text-align:left">字符串、数学</td></tr><tr><td style="text-align:left">拥有最多糖果的孩子</td><td style="text-align:left">1431</td><td style="text-align:left">数组遍历 + 条件判断</td><td style="text-align:left">数组</td></tr><tr><td style="text-align:left">种花问题</td><td style="text-align:left">605</td><td style="text-align:left">贪心（跳跃式种植）</td><td style="text-align:left">数组、贪心</td></tr><tr><td style="text-align:left">反转字符串中的元音字母</td><td style="text-align:left">345</td><td style="text-align:left">双指针交换元素</td><td style="text-align:left">字符串、双指针</td></tr><tr><td style="text-align:left">反转字符串中的单词</td><td style="text-align:left">151</td><td style="text-align:left">双指针分段处理</td><td style="text-align:left">字符串、双指针</td></tr><tr><td style="text-align:left">除自身以外数组的乘积</td><td style="text-align:left">238</td><td style="text-align:left">前缀积（空间优化技巧）</td><td style="text-align:left">数组、前缀和</td></tr><tr><td style="text-align:left">递增的三元子序列</td><td style="text-align:left">334</td><td style="text-align:left">贪心（维护最小候选值）</td><td style="text-align:left">数组、贪心</td></tr><tr><td style="text-align:left">压缩字符串</td><td style="text-align:left">443</td><td style="text-align:left">双指针原地修改</td><td style="text-align:left">字符串、双指针</td></tr></tbody></table></div><hr><h2 id="二、题目详解与代码实现"><a href="#二、题目详解与代码实现" class="headerlink" title="二、题目详解与代码实现"></a><strong>二、题目详解与代码实现</strong></h2><h3 id="1-1768-交替合并字符串"><a href="#1-1768-交替合并字符串" class="headerlink" title="1. 1768. 交替合并字符串"></a><strong>1. 1768. 交替合并字符串</strong></h3><p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/merge-strings-alternately/">1768. 交替合并字符串</a></p><p><strong>题目解析</strong>：交替合并给定的字符串 <code>word1</code> 和 <code>word2</code> 。  </p><p><strong>解法</strong>：使用两个指针，直接按要求模拟即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">mergeAlternately</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1 = word1.<span class="built_in">size</span>(), len2 = word2.<span class="built_in">size</span>();</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len1 || j &lt; len2; i++, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len1) ans += word1[i];</span><br><span class="line">            <span class="keyword">if</span> (j &lt; len2) ans += word2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：时间复杂度 $O(m + n)$，空间复杂度 $O(1)$</p><hr><h3 id="2-1071-字符串的最大公因子"><a href="#2-1071-字符串的最大公因子" class="headerlink" title="2. 1071. 字符串的最大公因子"></a><strong>2. 1071. 字符串的最大公因子</strong></h3><p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/greatest-common-divisor-of-strings/">1071. 字符串的最大公因子</a><a href="https://leetcode.cn/problems/greatest-common-divisor-of-strings/"></a></p><p><strong>题目解析</strong>：给定两个字符串 <code>str1</code> 和 <code>str2</code> 。返回 <em>最长字符串 <code>x</code>，要求满足 <code>x</code> 能除尽 <code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code></em> 。</p><p><strong>解法</strong>：常规的解法模拟即可，而对于最大公因数算法，不难想到，如果它们有公因子 <code>abc</code>，那么 <code>str1</code> 就是 <code>m</code>个 <code>abc</code> 的重复，<code>str2</code> 是 <code>n</code>个 <code>abc</code> 的重复，连起来就是 <code>m+n</code> 个 <code>abc</code>，而 <code>m+n</code> 个 <code>abc</code> 跟 <code>n+m</code> 个 <code>abc</code> 是一样的。所以如果 <code>str1 + str2 === str2 + str1</code> 就意味着有解。我们也很容易想到 <code>str1 + str2 !== str2 + str1</code> 也是无解的充要条件。故当确定有解的情况下，最优解是长度为 <code>gcd(str1.length, str2.length)</code> 的字符串。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">gcdOfStrings</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 + str2 != str2 + str1)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="built_in">gcd</span>(str1.<span class="built_in">size</span>(), str2.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：时间复杂度 $O(n)$，空间复杂度 $O(n)$</p><hr><h4 id="3-移除元素（27-Remove-Element）"><a href="#3-移除元素（27-Remove-Element）" class="headerlink" title="3. 移除元素（27. Remove Element）"></a><strong>3. 移除元素（27. Remove Element）</strong></h4><p><strong>题目</strong>：原地移除所有等于 <code>val</code> 的元素。<br><strong>解法</strong>：双指针覆盖<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">nums, val</span>):</span><br><span class="line">    slow = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><br><strong>心得</strong>：类似去重问题，注意元素顺序可改变时的优化技巧（如交换法）。</p><hr><p>（以下为简要框架，完整版需补充剩余题目）</p><hr><h3 id="三、刷题心得总结"><a href="#三、刷题心得总结" class="headerlink" title="三、刷题心得总结"></a><strong>三、刷题心得总结</strong></h3><ol><li><strong>双指针的普适性</strong>：覆盖数组去重、子序列、滑动窗口等问题。</li><li><strong>贪心算法的直觉培养</strong>：如跳跃游戏中“最大可达距离”的实时更新。</li><li><strong>边界条件处理</strong>：数组越界、空输入、全相同元素等极端情况需优先测试。</li><li><strong>空间复杂度优化</strong>：原地修改是面试加分项，需熟练掌握。</li><li><strong>数学规律挖掘</strong>：如多数元素的“投票法”需理解背后的数学原理。</li></ol><hr><h3 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a><strong>四、结语</strong></h3><p>数组/字符串问题侧重基础操作与思维敏捷性。建议按分类刷题，总结模板，逐步培养对时间复杂度与空间优化的敏感度。后续将更新链表、二叉树等专题，欢迎持续关注！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;LeetCode75 是面向算法面试的经典题库，涵盖高频考点与核心思想。本文将针对「数组 / 字符串」专题的 9 道题目，提供简洁清晰的题解思路、代码实现与刷题心得，助你快速掌握解题框架。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Make Carrot Great Again！</title>
    <link href="http://example.com/2024/01/31/Carrot/"/>
    <id>http://example.com/2024/01/31/Carrot/</id>
    <published>2024-01-31T03:57:59.195Z</published>
    <updated>2025-02-24T01:36:19.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="胡萝卜牛逼"><a href="#胡萝卜牛逼" class="headerlink" title="胡萝卜牛逼"></a>胡萝卜牛逼</h1><p>一些小小的测试，致敬胡萝卜！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;胡萝卜牛逼&quot;&gt;&lt;a href=&quot;#胡萝卜牛逼&quot; class=&quot;headerlink&quot; title=&quot;胡萝卜牛逼&quot;&gt;&lt;/a&gt;胡萝卜牛逼&lt;/h1&gt;&lt;p&gt;一些小小的测试，致敬胡萝卜！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis，启动！</title>
    <link href="http://example.com/2023/08/28/Redis%EF%BC%8C%E5%90%AF%E5%8A%A8%EF%BC%81/"/>
    <id>http://example.com/2023/08/28/Redis%EF%BC%8C%E5%90%AF%E5%8A%A8%EF%BC%81/</id>
    <published>2023-08-28T06:35:37.000Z</published>
    <updated>2025-03-07T08:14:47.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Redis基础概念"><a href="#1-Redis基础概念" class="headerlink" title="1. Redis基础概念"></a>1. Redis基础概念</h2><h3 id="1-1-什么是Redis"><a href="#1-1-什么是Redis" class="headerlink" title="1.1. 什么是Redis"></a>1.1. 什么是Redis</h3><p><strong>Redis（Remote Dictionary Server）</strong>是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息中间件。它被设计成高性能、低延迟的键值存储系统，常用于加速应用程序的数据访问，特别是那些需要频繁读写的场景。</p><p><img src="https://pic1.imgdb.cn/item/67caaab0066befcec6e0334c.webp" alt="1"></p><span id="more"></span><h3 id="1-2-为什么用Redis"><a href="#1-2-为什么用Redis" class="headerlink" title="1.2. 为什么用Redis"></a>1.2. 为什么用Redis</h3><p>与传统的关系型数据库（SQL）不同，Redis是一个键值存储系统，数据以键值对的形式存储，值可以是字符串、哈希、列表、集合、有序集合等数据结构。同时，它还具有一些自己的关键特点：</p><ul><li><strong>内存存储：</strong> Redis 将数据存储在内存中，这使得数据的读写速度非常快，适合对延迟敏感的应用。</li><li><strong>键值存储：</strong> Redis 使用键值对（key-value）的方式存储数据。每个键都是一个字符串，与之相关联的值可以是字符串、哈希、列表、集合、有序集合等数据结构。</li><li><strong>持久化支持：</strong> Redis 提供了两种持久化方式，分别是快照（snapshotting）和追加日志文件（append-only file），这样可以在服务器重启后恢复数据。</li><li><strong>数据结构支持：</strong> Redis 不仅仅是简单的键值存储，还支持多种复杂的数据结构，如哈希表（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，这使得它适用于不同种类的应用场景。</li><li><strong>发布订阅：</strong> Redis 支持发布-订阅模式，允许多个客户端订阅一个或多个频道，当某个频道的消息被发布时，订阅者将收到相应的消息。</li><li><strong>高可用性：</strong> Redis 支持主从复制和哨兵模式，可以实现数据的备份和故障转移，提高系统的可用性。</li><li><strong>分布式缓存：</strong> Redis 常被用作分布式缓存，可以在应用程序和后端数据存储之间起到缓冲的作用，减轻数据库的负载。</li><li><strong>事务支持：</strong> Redis 支持简单的事务，通过 MULTI、EXEC、DISCARD 和 WATCH 等命令可以实现一系列命令的原子性执行。</li></ul><p>因此，对于大多数的业务场景中，我们通常将 Redis 与 SQL 一起使用，但二者的用途不同。SQL 用于持久性数据存储和复杂查询，而 Redis 则用于高速缓存、实时计数、消息队列等。在项目中是否需要同时使用它们取决于项目的具体需求和性能优化的目标，从而共同发挥他们的优势。</p><h2 id="2-安装与启动"><a href="#2-安装与启动" class="headerlink" title="2. 安装与启动"></a>2. 安装与启动</h2><p>对于 Redis 的安装部分，我们只需要下载对应版本的安装文件包即可，这里给出链接<a href="https://github.com/tporadowski/redis/releases">Redis (github.com)</a>，目前最新的版本为 <code>5.0.14.1</code></p><p><img src="https://pic1.imgdb.cn/item/67caaab1066befcec6e03351.png" alt="2"></p><p>在下载解压之后，我们进入解压后的文件夹路径，输入以下命令启动 Redis 服务</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/67caaab1066befcec6e03353.png" alt="3"></p><p>此时可以看到 Redis 的 Logo 和启动成功的信息，默认端口号为 <code>6379</code>。</p><p>我们保持 <strong>redis-server</strong> 即服务器端运行，再次打开一个cmd窗口，启动 <strong>redis-cli</strong> 即客户端，即可创建我们的键值对了。</p><p><img src="https://pic1.imgdb.cn/item/67caaab2066befcec6e03355.png" alt="4"></p><p>至此，Redis的安装与简单使用部分我们已经完成了，接下来就是更加深入的使用方法了。</p><h2 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3. 基本语法"></a>3. 基本语法</h2><div class="table-container"><table><thead><tr><th>数据类型</th><th>介绍</th><th>特性</th><th>用法</th></tr></thead><tbody><tr><td>String(字符串)</td><td>一个可变的字节数组</td><td>可以包含任何数据,比如jpg图片或者序列化的对象（最大存储512M ）</td><td>初始化、获取、长度、子串、覆盖、追加、计数、过期、删除等操作</td></tr><tr><td>Hash(哈希)</td><td>二维结构，第一维是数组，第二维是链表（HashMap）</td><td>一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象</td><td>存储、读取、修改，普通用户属性</td></tr><tr><td>List(列表)</td><td>链表(双向链表)，按照插入顺序排序</td><td>随机定位性能较弱，首尾插入删除性能较优。可以使用自然数或者负下标（从-1开始递减）</td><td>适合做消息队列，有时间线的列表呈现</td></tr><tr><td>Set(集合)</td><td>哈希表实现无序集合</td><td>添加，删除，查找的复杂度都是 O(1)，重复元素自动忽略</td><td>利用唯一性,统计访问网站的所有独立ip，不重复的序列呈现</td></tr><tr><td>Sorted Set(有序集合)</td><td>将Set中的元素增加一个权重参数score（double）,元素按score有序排列</td><td>score可重复，按从小到大自动排序</td><td>排行榜等需要排序的列表呈现</td></tr></tbody></table></div><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h3 id="3-1-String"><a href="#3-1-String" class="headerlink" title="3.1. String"></a>3.1. String</h3><ul><li>string 是 redis 最基本的类型</li><li>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</li><li>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</li></ul><h3 id="3-2-hash"><a href="#3-2-hash" class="headerlink" title="3.2. hash"></a>3.2. hash</h3><ul><li>Redis hash 是一个键值(key=&gt;value)对集合。</li><li>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</li></ul><h3 id="3-3-list"><a href="#3-3-list" class="headerlink" title="3.3. list"></a>3.3. list</h3><ul><li>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lpush ListDemo first</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush ListDemo second</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush ListDemo third</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange ListDemo 0 10</span><br><span class="line">1) <span class="string">&quot;first&quot;</span></span><br><span class="line">2) <span class="string">&quot;second&quot;</span></span><br><span class="line">3) <span class="string">&quot;third&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="3-4-set"><a href="#3-4-set" class="headerlink" title="3.4. set"></a>3.4. set</h3><ul><li>集合是一个无序的字符串元素集合，支持添加、删除、查找等操作。</li><li>集合可以用于存储唯一的元素，也可以进行交集、并集等操作。</li><li>使用<code>sadd key member</code>向集合添加键值对，成功返回1，如果元素已经在集合中返回 0。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; sadd SetDemo first</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd SetDemo second</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd SetDemo third</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd SetDemo third</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers SetDemo</span><br><span class="line">1) <span class="string">&quot;first&quot;</span></span><br><span class="line">2) <span class="string">&quot;second&quot;</span></span><br><span class="line">3) <span class="string">&quot;third&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-5-Sorted-Set"><a href="#3-5-Sorted-Set" class="headerlink" title="3.5. Sorted Set"></a>3.5. Sorted Set</h3><ul><li>有序集合类似于集合，但每个元素都关联着一个分数（score），用于排序元素。</li><li>有序集合通常用于实现排行榜、范围查找等功能。</li><li>使用<code>zadd key score member</code>向有序集合添加内容，成功返回1，如果元素已经在集合中返回 0。</li><li>有序集合分数可不唯一。</li></ul><h2 id="4-Go与Redis"><a href="#4-Go与Redis" class="headerlink" title="4. Go与Redis"></a>4. Go与Redis</h2><p>在介绍完Redis的基本操作后，若想将其运用到我们的Go项目中，少不了的是 <strong>go-redis</strong> ，<code>go-redis</code> 是 Go 语言中一个流行的 Redis 客户端库，用于与 Redis 服务器进行交互。它提供了一组简单且强大的 API，使得在 Go 项目中操作 Redis 数据库变得更加方便和高效。</p><h3 id="4-1-服务端配置"><a href="#4-1-服务端配置" class="headerlink" title="4.1. 服务端配置"></a>4.1. 服务端配置</h3><p>对于服务端，当我们需要在程序中连接到 Redis 服务器时，通常会使用配置文件来存储与连接相关的信息，例如服务器地址、端口号、密码等。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;redis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;redis-server-address&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">6379</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your-password&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-客户端配置"><a href="#4-2-客户端配置" class="headerlink" title="4.2. 客户端配置"></a>4.2. 客户端配置</h3><p>而对于客户端，我们可以通过命令安装 <code>go-redis</code> 库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get github.com/go-redis/redis/v8</span><br></pre></td></tr></table></figure><p>并在相应的文件中导入即可</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br></pre></td></tr></table></figure><p>调用时，使用 <code>redis.NewClient</code> 函数创建一个客户端实例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">options := &amp;redis.Options&#123;</span><br><span class="line">    Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">    Password: <span class="string">&quot;&quot;</span>,               <span class="comment">// Redis 密码，默认为空</span></span><br><span class="line">    DB:       <span class="number">0</span>,                <span class="comment">// 数据库编号，默认为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client := redis.NewClient(options)</span><br></pre></td></tr></table></figure><p>同时对于键值对的 set 和 get 操作，也同样可以执行</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键值对</span></span><br><span class="line">err := client.Set(ctx, <span class="string">&quot;KeyDemo&quot;</span>, <span class="string">&quot;ValueDemo&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line">value, err := client.Get(ctx, <span class="string">&quot;KeyDemo&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;KeyDemo:&quot;</span>, value)</span><br></pre></td></tr></table></figure><p>当然，当我们完成交互后，别忘了关闭链接释放资源。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := client.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>好了，本篇文章到这里就结束了，Redis 作为一款功能强大的数据库，极大的便利了我们的开发，文章中如有不足，还请读者多多指出，谢谢！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-Redis基础概念&quot;&gt;&lt;a href=&quot;#1-Redis基础概念&quot; class=&quot;headerlink&quot; title=&quot;1. Redis基础概念&quot;&gt;&lt;/a&gt;1. Redis基础概念&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是Redis&quot;&gt;&lt;a href=&quot;#1-1-什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;1.1. 什么是Redis&quot;&gt;&lt;/a&gt;1.1. 什么是Redis&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Redis（Remote Dictionary Server）&lt;/strong&gt;是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息中间件。它被设计成高性能、低延迟的键值存储系统，常用于加速应用程序的数据访问，特别是那些需要频繁读写的场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.imgdb.cn/item/67caaab0066befcec6e0334c.webp&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Go Web 入门与实战系列：高性能 Web 框架 Gin</title>
    <link href="http://example.com/2023/08/27/Go%20Web%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%20Web%20%E6%A1%86%E6%9E%B6%20Gin/"/>
    <id>http://example.com/2023/08/27/Go%20Web%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%20Web%20%E6%A1%86%E6%9E%B6%20Gin/</id>
    <published>2023-08-27T12:58:23.000Z</published>
    <updated>2025-03-07T08:11:22.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前面的话"><a href="#0-前面的话" class="headerlink" title="0. 前面的话"></a>0. 前面的话</h2><p><strong>Web应用程序（Web Application）</strong>是一种通过网络（通常是互联网）访问的软件应用程序。与传统的桌面应用程序不同，Web应用程序运行在Web浏览器中，并通过与远程服务器的交互来提供功能和服务。用户可以通过在浏览器中输入URL或点击链接来访问Web应用程序。</p><p>而在 Go 语言中，最常用的 Web 框架便是我们熟知的 Gin 框架，Gin 是一个轻量级的 Web 框架，具有快速的路由和中间件支持。它被设计为高性能且易于使用，适用于构建各种规模的 Web 应用程序。</p><p>本篇文章将为大家简单介绍 Gin 框架的基本用法。</p><span id="more"></span><h2 id="1-简单上手"><a href="#1-简单上手" class="headerlink" title="1. 简单上手"></a>1. 简单上手</h2><h3 id="1-1-安装与使用"><a href="#1-1-安装与使用" class="headerlink" title="1.1. 安装与使用"></a>1.1. 安装与使用</h3><p>安装 Gin 非常简单，只需要打开终端输入以下指令即可</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>安装完成后，在后续的使用中，我们只需要导入该包即可</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Hello-World"><a href="#1-2-Hello-World" class="headerlink" title="1.2. Hello World"></a>1.2. Hello World</h3><p>按照传统惯例，一段<code>Hello World</code>是少不了的，我们可建立文件编写下列代码来实现</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line">router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run(<span class="string">&quot;:8090&quot;</span>) <span class="comment">// 默认监听8080端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Gin 实现 Hello world 非常简单，创建一个路由 router，然后执行 Run 方法即可。</p><p>对于上述的代码，我们来简单分析一下代码结构：</p><ul><li>1、<code>router := gin.Default()</code>：这是默认的服务器。使用gin的<code>Default</code>方法创建一个路由<code>Handler</code>；</li><li>2、然后通过Http方法绑定路由规则和路由函数。不同于<code>net/http</code>库的路由函数，gin进行了封装，把<code>reques</code>t和<code>response</code>都封装到了<code>gin.Context</code>的上下文环境中。</li><li>3、最后启动路由的Run方法监听端口。还可以用<code>http.ListenAndServe(&quot;:8080&quot;, router)</code>，或者自定义Http服务器配置。</li></ul><p>简单几行代码，就能实现一个web服务。使用gin的Default方法创建一个路由handler。然后通过HTTP方法绑定路由规则和路由函数。不同于net/http库的路由函数，gin进行了封装，把request和response都封装到gin.Context的上下文环境。最后是启动路由的Run方法监听端口。麻雀虽小，五脏俱全。当然，除了GET方法，gin也支持POST、PUT、DELETE、OPTION等常用的restful方法。</p><h2 id="2-Restful-路由"><a href="#2-Restful-路由" class="headerlink" title="2. Restful 路由"></a>2. Restful 路由</h2><h3 id="2-1-路由的定义"><a href="#2-1-路由的定义" class="headerlink" title="2.1. 路由的定义"></a>2.1. 路由的定义</h3><p>在 Gin 框架中，路由定义是指将 <strong>URL 路径</strong>映射到相应的处理函数，以便根据客户端发起的请求来执行特定的操作。Gin 支持常见的 <strong>HTTP</strong> 请求方法（GET、POST、PUT、DELETE 等），可以根据不同的请求方法来定义相应的路由。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 处理 GET /hello 请求的代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.POST(<span class="string">&quot;/create&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 处理 POST /create 请求的代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.PUT(<span class="string">&quot;/update/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 处理 PUT /update/:id 请求的代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.DELETE(<span class="string">&quot;/delete/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 处理 DELETE /delete/:id 请求的代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上述示例中，每个方法的第一个参数是一个字符串，表示要匹配的 URL 路径。当客户端发起对应的 HTTP 请求时，Gin 框架将调用指定的处理函数，这个函数的参数是一个 <code>gin.Context</code> 对象，通过它可以访问请求信息和构建响应。</p><h3 id="2-2-路由参数"><a href="#2-2-路由参数" class="headerlink" title="2.2. 路由参数"></a>2.2. 路由参数</h3><p>Gin 的路由来自 httprouter 库。因此 httprouter 具有的功能， Gin 也具有，不过 Gin 不支持路由正则表达式。</p><h4 id="2-2-1-API参数"><a href="#2-2-1-API参数" class="headerlink" title="2.2.1. API参数"></a>2.2.1. API参数</h4><p>api 参数通过Context的Param方法来获取。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/user/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    c.String(http.StatusOK, name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>冒号<code>:</code>加上一个参数名组成路由参数。可以使用 c.Params 的方法读取其值。当然这个值是字串 string。诸如<code>/user/hanru</code>，和<code>/user/hello</code>都可以匹配，而<code>/user/</code>和<code>/user/hanru/</code>不会被匹配。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/user/:name/*action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    action := c.Param(<span class="string">&quot;action&quot;</span>)</span><br><span class="line">    message := name + <span class="string">&quot; is &quot;</span> + action</span><br><span class="line">    c.String(http.StatusOK, message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-2-2-URL参数"><a href="#2-2-2-URL参数" class="headerlink" title="2.2.2. URL参数"></a>2.2.2. URL参数</h4><p>Web 提供的服务通常是 client 和 server 的交互。其中客户端向服务器发送请求，除了路由参数，其他的参数无非两种，查询字符串 query string 和报文体 body 参数。所谓 Query string，即查询字符串，用 <code>?</code>以后连接的 <code>key1 = value2 &amp; key2 = value2</code> 的形式的参数。当然这个 key-value 是经过 urlencode 编码。</p><p>URL 参数通过 DefaultQuery 或 Query 方法获取。</p><p>对于参数的处理，经常会出现参数不存在的情况，对于是否提供默认值，Gin 也考虑了，并且给出了一个优雅的方案，使用 <code>c.DefaultQuery</code> 方法读取参数，其中当参数不存在的时候，提供一个默认值。使用 Query 方法读取正常参数，当参数不存在的时候，返回空字串。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/welcome&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        name := c.DefaultQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Guest&quot;</span>) <span class="comment">//可设置默认值</span></span><br><span class="line">        <span class="comment">//nickname := c.Query(&quot;nickname&quot;) // 是 c.Request.URL.Query().Get(&quot;nickname&quot;) 的简写</span></span><br><span class="line">        c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;Hello %s &quot;</span>, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    router.Run(<span class="string">&quot;:8090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-表单参数"><a href="#2-2-3-表单参数" class="headerlink" title="2.2.3 表单参数"></a>2.2.3 表单参数</h4><p>http 的报文体传输数据就比 query string 稍微复杂一点，常见的格式就有四种。</p><p>例如<code>application/json</code>，<code>application/x-www-form-urlencoded</code>,<code>application/xml</code>和<code>multipart/form-data</code>。后面一个主要用于图片上传。</p><p>json格式的很好理解，urlencode其实也不难，无非就是把query string的内容，放到了body体里，同样也需要urlencode。</p><p>默认情况下，<code>c.PostFROM</code> 解析的是<code>x-www-form-urlencoded</code>或<code>from-data</code>的参数。</p><p>表单参数通过 <code>PostForm</code> 方法获取：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    <span class="comment">//form</span></span><br><span class="line">    router.POST(<span class="string">&quot;/form&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        type1 := c.DefaultPostForm(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;alert&quot;</span>) <span class="comment">//可设置默认值</span></span><br><span class="line">        username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">        password := c.PostForm(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//hobbys := c.PostFormMap(&quot;hobby&quot;)</span></span><br><span class="line">        <span class="comment">//hobbys := c.QueryArray(&quot;hobby&quot;)</span></span><br><span class="line">        hobbys := c.PostFormArray(<span class="string">&quot;hobby&quot;</span>)</span><br><span class="line"></span><br><span class="line">        c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;type is %s, username is %s, password is %s,hobby is %v&quot;</span>, type1, username, password,hobbys))</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    router.Run(<span class="string">&quot;:8090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3. 中间件"></a>3. 中间件</h2><p>中间件的意思就是，对一组接口的统一操作，可以把逻辑提取出来，类似于横切关注点，常用于一些记录 log，错误 handler，还有就是对部分接口的鉴权。</p><p>比如有一组 API 接口是用户登入后的操作，我们就需要在进入每个 API 接口前都进行权限的验证。有了中间件后，我们只需要创建一个中间件，权限的验证放到中间件，然后把 这个中间件绑定到那一组 API 上即可。下面就实现一个简易的鉴权中间件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthMiddleWare</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">token := c.Request.Header.Get(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">authorized := check(token) <span class="comment">//调用认证方法</span></span><br><span class="line"><span class="keyword">if</span>  authorized &#123;</span><br><span class="line">c.Next()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusUnauthorized, gin.H&#123;</span><br><span class="line"><span class="string">&quot;error&quot;</span>: <span class="string">&quot;Unauthorized&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">c.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/path&quot;</span>, AuthMiddleWare(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;data&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个 AuthMiddleWare 中间件，中间件的功能是提测请求的头部 Authorization，将获取的 token 调用认证方法判断，是否是合法的 token。在处理器中，增加 AuthMiddleWare() 中间件即可。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.  小结"></a>4.  小结</h2><p>总的来说，Gin 是一个轻巧而强大的 Golang Web 框架，路由性能高，在各种 Web 框架中处于领先地位。Gin 框架一直是敏捷开发中的利器，能让开发者很快的上手并做出应用。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-前面的话&quot;&gt;&lt;a href=&quot;#0-前面的话&quot; class=&quot;headerlink&quot; title=&quot;0. 前面的话&quot;&gt;&lt;/a&gt;0. 前面的话&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Web应用程序（Web Application）&lt;/strong&gt;是一种通过网络（通常是互联网）访问的软件应用程序。与传统的桌面应用程序不同，Web应用程序运行在Web浏览器中，并通过与远程服务器的交互来提供功能和服务。用户可以通过在浏览器中输入URL或点击链接来访问Web应用程序。&lt;/p&gt;
&lt;p&gt;而在 Go 语言中，最常用的 Web 框架便是我们熟知的 Gin 框架，Gin 是一个轻量级的 Web 框架，具有快速的路由和中间件支持。它被设计为高性能且易于使用，适用于构建各种规模的 Web 应用程序。&lt;/p&gt;
&lt;p&gt;本篇文章将为大家简单介绍 Gin 框架的基本用法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何将我的服务开放给用户：构建 API 接口和用户认证的实践</title>
    <link href="http://example.com/2023/08/24/%E6%9E%84%E5%BB%BAAPI%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2023/08/24/%E6%9E%84%E5%BB%BAAPI%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</id>
    <published>2023-08-24T07:29:33.000Z</published>
    <updated>2025-03-07T07:42:17.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前情提要"><a href="#0-前情提要" class="headerlink" title="0. 前情提要"></a>0. 前情提要</h2><p>在学习完 Gin 和 Gorm 之后，我们逐步完成了后端部分的代码，而对于前后端分离开发模式下，后端工程师需要通过查询前端提供的接口文档，参与共同定义接口（分为四部分：方法、uri、请求参数、返回参数），并根据这个接口进行后端代码的实现。因此学习如何构建API接口对于项目的开发尤为重要。</p><span id="more"></span><h2 id="1-构建API接口"><a href="#1-构建API接口" class="headerlink" title="1. 构建API接口"></a>1. 构建API接口</h2><h3 id="1-1-构建基础API接口"><a href="#1-1-构建基础API接口" class="headerlink" title="1.1. 构建基础API接口"></a>1.1. 构建基础API接口</h3><p>首先，我们必须创建一个非常简单的服务器来处理HTTP请求。</p><p>为此，我们创建一个名为 <code>main.go</code> 的新文件。 在这个 <code>main.go</code> 文件中，我们将要定义3个不同的函数。</p><ul><li><strong>page</strong>函数，是一个处理HTTP请求的处理程序。它接受两个参数：<code>w</code> 是一个 <code>http.ResponseWriter</code>，用于向客户端发送响应，<code>r</code> 是一个 <code>http.Request</code>，包含了客户端发送的请求信息。</li><li><strong>router</strong>函数，它设置了路由和启动HTTP服务器。</li><li><strong>main</strong>函数，它则用于启动API</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">page</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">router</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, page)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写好后我们点击运行，浏览器打开<a href="http://localhost:8090/，就可以看到">http://localhost:8090/，就可以看到</a> <code>Hello!</code> ，说明我们现在已经成功创建了一个基础的API。</p><p><img src="https://pic1.imgdb.cn/item/67caa2d8066befcec6e02167.png" alt=""></p><h3 id="1-2-RESTful-API"><a href="#1-2-RESTful-API" class="headerlink" title="1.2. RESTful API"></a>1.2. RESTful API</h3><p>RESTful API（Representational State Transferful Application Programming Interface）是一种设计和构建网络应用程序的架构风格，用于处理资源的访问和操作。它遵循一组约定和规则，使得客户端和服务器之间的通信变得简单、灵活和可伸缩。</p><p>以下是RESTful API的主要特点和概念：</p><ol><li><p><strong>资源（Resources）：</strong> 在RESTful API中，所有数据都被视为资源。每个资源都有一个唯一的标识符（通常是URL），通过这个标识符来访问和操作资源。</p></li><li><p><strong>HTTP方法（HTTP Methods）：</strong> RESTful API使用HTTP方法来表示对资源的不同操作。常用的HTTP方法包括：</p><ul><li>GET：获取资源的信息。</li><li>POST：创建新资源。</li><li>PUT：更新现有资源。</li><li>DELETE：删除资源。</li></ul></li><li><p><strong>状态无关性（Stateless）：</strong> RESTful API的通信是无状态的，每个请求都是独立的。服务器不会存储客户端的状态，所有必要的信息都包含在请求中。</p></li><li><p><strong>统一接口（Uniform Interface）：</strong> RESTful API采用一组统一的接口约定，包括使用统一的资源标识符（URL）来访问资源，使用标准的HTTP方法来操作资源，以及通过HTTP状态码来传达请求的结果。</p></li><li><p><strong>资源的表示（Representation）：</strong> 客户端可以通过不同的表示形式（如JSON、XML等）获取资源的信息。服务器将资源的状态以适当的表示形式返回给客户端。</p></li><li><p><strong>超媒体驱动（HATEOAS）：</strong> 这是RESTful API的一个特点，它允许服务器在响应中提供相关资源的链接，从而允许客户端动态地探索和访问其他相关资源。</p></li><li><p><strong>缓存支持：</strong> RESTful API支持HTTP的缓存机制，以提高性能和降低服务器负载。</p></li></ol><p>RESTful API的设计和使用遵循一些最佳实践，例如：</p><ul><li>使用有意义的URL，用于表示资源的层次结构和关系。</li><li>使用适当的HTTP状态码来表示请求的结果，如成功、错误等。</li><li>使用合适的HTTP头部来传递元数据，如身份验证信息、内容类型等。</li></ul><p>通过遵循这些原则，RESTful API可以提供灵活、可扩展和易于理解的接口，使客户端和服务器之间的通信变得更加简单和高效。</p><h3 id="1-3-使用Gin优化接口"><a href="#1-3-使用Gin优化接口" class="headerlink" title="1.3. 使用Gin优化接口"></a>1.3. 使用Gin优化接口</h3><p>Gin 是一个基于 Go 语言的轻量级 Web 框架，专注于高性能的路由和中间件支持。</p><p>而第一步遍是我们的安装操作，我们可以使用 Go 的包管理工具 <code>go get</code> 进行安装。然后在项目中引入 Gin 包。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>安装完成后，我们就可以很容易地创建路由和处理程序函数。路由是将 URL 路径映射到处理程序函数的方式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello, World!&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    router.Run(<span class="string">&quot;:8090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时 Gin 还提供了中间件的支持，您可以在请求处理前后执行某些操作，如日志记录、身份验证等。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoggerMiddleware</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 执行前置操作</span></span><br><span class="line">        log.Println(<span class="string">&quot;Request received&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续处理请求</span></span><br><span class="line">        c.Next()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行后置操作</span></span><br><span class="line">        log.Println(<span class="string">&quot;Request handled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.Use(LoggerMiddleware())</span><br><span class="line"></span><br><span class="line">    router.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello, World!&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    router.Run(<span class="string">&quot;:8090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-用户认证"><a href="#2-用户认证" class="headerlink" title="2. 用户认证"></a>2. 用户认证</h2><h3 id="2-1-什么是用户认证"><a href="#2-1-什么是用户认证" class="headerlink" title="2.1. 什么是用户认证"></a>2.1. 什么是用户认证</h3><p>用户认证是确认用户身份的过程，确保只有合法用户可以访问你的服务。在API开放给公众使用时，用户认证尤为重要，防止未经授权的访问和滥用。</p><h3 id="2-2-常见的用户认证方式"><a href="#2-2-常见的用户认证方式" class="headerlink" title="2.2. 常见的用户认证方式"></a>2.2. 常见的用户认证方式</h3><ul><li>基本认证：用户通过在请求头中提供用户名和密码进行认证。但是这种方式不够安全，因为密码是明文传输的，容易被截获。</li><li>Bearer令牌认证：用户在请求头中使用令牌来认证。令牌通常是由服务器签发的加密字符串，比较安全，不需要传输密码。</li><li>OAuth认证：OAuth是一个用于授权的开放标准，允许用户授权第三方应用访问他们的资源。这是常见的社交媒体登录方式。</li></ul><p>在Go语言中，我们一般使用 <code>jwt-go</code> 包来处理JWT令牌。</p><h3 id="2-3-JWT"><a href="#2-3-JWT" class="headerlink" title="2.3. JWT"></a>2.3. JWT</h3><p><strong>JWT（JSON Web Token）</strong>是一种用于安全地在不同实体之间传递信息的开放标准。它通常用于身份验证和授权，以及在应用程序之间安全地传输声明（claims）。JWT是一种紧凑且自包含的格式，以JSON格式表示，可以通过网络传输，并且在受信任的实体之间进行验证。</p><p>一个 JWT 通常由三个部分组成，通过点号 <code>.</code> 分隔：</p><ul><li><strong>Header（头部）</strong> ：包含了令牌的类型（通常是 “JWT”）和使用的加密算法，例如 HMAC SHA256 或 RSA。</li><li><strong>Payload（负载）</strong> ：包含了一些声明（claims），如令牌的主题（subject）、到期时间（expiration time）、发布者（issuer）等。这些信息是关于令牌的附加信息。</li><li><strong>Signature（签名）</strong> ：使用头部和负载以及一个密钥（secret）来创建，以确保令牌没有被篡改。</li></ul><p>下面的代码中，我们实现了一个简单的JWT令牌认证中间件，用户在请求头中提供JWT令牌进行认证。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authMiddleware</span><span class="params">(next http.HandlerFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        tokenString := r.Header.Get(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> tokenString == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            http.Error(w, <span class="string">&quot;未提供令牌&quot;</span>, http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token, err := jwt.Parse(tokenString, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;your-secret-key&quot;</span>), <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> || !token.Valid &#123;</span><br><span class="line">            http.Error(w, <span class="string">&quot;令牌无效&quot;</span>, http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello, authenticated Gophers!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line"></span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/hello&quot;</span>, authMiddleware(helloHandler))</span><br><span class="line">    http.Handle(<span class="string">&quot;/&quot;</span>, r)</span><br><span class="line"></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>通过构建API接口和用户认证，服务将变得更加强大和灵活，并且得到更多用户的喜爱和信赖。</p><p>同时提供清晰明了的API文档，也可以方便用户更好地理解和使用自己的服务。</p><p>文章中只是简单介绍了相关知识，可能还有欠缺，还请多多包涵。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-前情提要&quot;&gt;&lt;a href=&quot;#0-前情提要&quot; class=&quot;headerlink&quot; title=&quot;0. 前情提要&quot;&gt;&lt;/a&gt;0. 前情提要&lt;/h2&gt;&lt;p&gt;在学习完 Gin 和 Gorm 之后，我们逐步完成了后端部分的代码，而对于前后端分离开发模式下，后端工程师需要通过查询前端提供的接口文档，参与共同定义接口（分为四部分：方法、uri、请求参数、返回参数），并根据这个接口进行后端代码的实现。因此学习如何构建API接口对于项目的开发尤为重要。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Gorm 学习记录</title>
    <link href="http://example.com/2023/08/23/Gorm%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2023/08/23/Gorm%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-08-23T02:53:33.000Z</published>
    <updated>2025-03-07T07:37:47.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文章为自己在基于课程视频时学习Gorm所得心得体会，本人拙见，若有不足之处，还请各位多多指出。</p></blockquote><h2 id="1-什么是Gorm"><a href="#1-什么是Gorm" class="headerlink" title="1. 什么是Gorm"></a>1. 什么是Gorm</h2><p><strong>Gorm</strong>（全称：Go Object Relational Mapping）是一个针对 Go 语言的对象关系映射（ORM）库。ORM 是一种编程技术，用于在关系型数据库和编程语言对象之间建立映射关系，使开发者能够使用面向对象的方式操作数据库，而不必直接编写 SQL 查询语句。</p><span id="more"></span><p>Gorm 在 Go 语言中提供了一种简化数据库操作的方式，它允许开发者定义结构体来表示数据库表格，然后通过 Gorm 提供的方法进行数据库的增、删、改、查操作，而无需手动编写 SQL 语句。Gorm 支持多种数据库后端，如 MySQL、PostgreSQL、SQLite 等。</p><p>Gorm 的主要特点包括：</p><ol><li><strong>模型定义</strong>：通过定义 Go 结构体来映射数据库表格，可以指定字段的名称、数据类型、主键、索引等属性。</li><li><strong>查询构建</strong>：Gorm 提供了丰富的查询构建方法，可以轻松地构造复杂的查询条件和排序规则，从而减少手写 SQL 查询的工作量。</li><li><strong>事务支持</strong>：Gorm 支持事务操作，可以确保数据库操作的原子性和一致性。</li><li><strong>预加载和延迟加载</strong>：可以通过预加载相关联的数据来优化查询性能，同时支持延迟加载以避免不必要的数据加载。</li><li><strong>钩子函数</strong>：可以在模型的不同生命周期阶段注册回调函数，实现自定义的业务逻辑。</li><li><strong>迁移工具</strong>：Gorm 提供了数据库迁移工具，可以自动同步数据库表结构和代码定义的模型。</li><li><strong>插件扩展</strong>：可以通过插件扩展 Gorm 的功能，例如添加缓存支持、审计日志等。</li></ol><h2 id="2-如何使用Gorm"><a href="#2-如何使用Gorm" class="headerlink" title="2. 如何使用Gorm"></a>2. 如何使用Gorm</h2><p><strong>Gorm</strong>的使用方式十分简单，只需要简单的几步操作即可进入CRUD的世界。</p><h3 id="2-1-下载gorm库"><a href="#2-1-下载gorm库" class="headerlink" title="2.1. 下载gorm库"></a>2.1. 下载gorm库</h3><p>最简单的方式就是直接使用命令下载安装Gorm</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get -u github.com/jinzhu/gorm</span><br></pre></td></tr></table></figure><p>当然，在有了<code>go mod</code>后，可以让其自动添加gorm的依赖包，也可以手动自行添加</p><p>更多相关操作可以参看<code>go-demo</code>的项目<a href="https://github.com/DMinerJackie/go-demo">DMinerJackie/go-demo: go to go (github.com)</a></p><h3 id="2-2-数据库连接"><a href="#2-2-数据库连接" class="headerlink" title="2.2. 数据库连接"></a>2.2. 数据库连接</h3><p>使用grom创建数据库连接</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:root@(127.0.0.1:3306)/db1?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err!= <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-定义模型"><a href="#2-3-定义模型" class="headerlink" title="2.3. 定义模型"></a>2.3. 定义模型</h3><p>定义自己的数据模型，以映射到 MySQL 数据库表格和操作数据。以下是一个关注模块的简单例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Follow <span class="keyword">struct</span> &#123;</span><br><span class="line">UserID     <span class="type">int64</span>     <span class="comment">// 关注人ID</span></span><br><span class="line">FollowerID <span class="type">int64</span>     <span class="comment">// 被关注人ID</span></span><br><span class="line">CreateAt   time.Time <span class="comment">// 关注发起时间</span></span><br><span class="line">Status     <span class="type">int8</span>      <span class="comment">// 关注状态（1：关注，默认0）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-创建表"><a href="#2-4-创建表" class="headerlink" title="2.4. 创建表"></a>2.4. 创建表</h3><p>对于表的创建，可以直接通过 <code>db.CreateTable</code> 创建表了，非常方便，还可以通过 <code>db.Set</code> 设置一些额外的表属性</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !db.HasTable(&amp;Follow&#123;&#125;) &#123;</span><br><span class="line"><span class="keyword">if</span> err := db.Set(<span class="string">&quot;gorm:table_options&quot;</span>, <span class="string">&quot;ENGINE=InnoDB DEFAULT CHARSET=utf8&quot;</span>).CreateTable(&amp;Follow&#123;&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-插入"><a href="#2-5-插入" class="headerlink" title="2.5. 插入"></a>2.5. 插入</h3><p>先构造已给对象，直接调用 db.Create() 就可以插入一条记录了</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">follow := model.Follow&#123;</span><br><span class="line">UserID:     userId,</span><br><span class="line">FollowerID: targetId,</span><br><span class="line">CreateAt:   date,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := config.DB.Select(<span class="string">&quot;UserId&quot;</span>, <span class="string">&quot;FollowerId&quot;</span>, <span class="string">&quot;CreateAt&quot;</span>).Create(&amp;follow).Error; <span class="literal">nil</span> != err &#123;</span><br><span class="line">log.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-删除"><a href="#2-6-删除" class="headerlink" title="2.6. 删除"></a>2.6. 删除</h3><p>先用 db.Where() 构造查询条件，再调用 db.Delete() 就可以删除</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := db.Where(&amp;Follow&#123;Hash: hash&#125;).Delete(Follow&#123;&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">eturn err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-修改"><a href="#2-7-修改" class="headerlink" title="2.7. 修改"></a>2.7. 修改</h3><p><code>Gorm</code>更新数据是通过<code>Update</code>函数操作的，<code>Update</code>函数需要传入要更新的字段和对应的值。</p><p>需要通过<code>Model</code>函数来传入要更新的模型，主要是用来确定表名，也可以使用<code>Table</code>函数来确定表名。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result := db.Model(&amp;Follow&#123;&#125;).Where(<span class="string">&quot;UserID = ?&quot;</span>, <span class="string">&quot;1&quot;</span>).Update(<span class="string">&quot;UserID&quot;</span>, <span class="string">&quot;2&quot;</span>) </span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123; </span><br><span class="line">log.Fatal(result.Error) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">log.Printf(<span class="string">&quot;Updated records: %d\n&quot;</span>, result.RowsAffected) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-查询"><a href="#2-8-查询" class="headerlink" title="2.8. 查询"></a>2.8. 查询</h3><p>先用 <code>db.Model()</code> 选择一个表，再用 <code>db.Where()</code> 构造查询条件，后面可以使用 <code>db.Count()</code> 计算数量，如果要获取对象，可以使用 <code>db.Find(&amp;Follow)</code> 或者只需要查一条记录 <code>db.First(&amp;Follow)</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">err := db.Model(&amp;Follow&#123;&#125;).Where(&amp;Follow&#123;UserId: uid, FollowerId: fid&#125;).Count(&amp;count).Error</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>至此，gorm的简单增删改查操作就已经介绍完了，gorm作为一款orm库，几乎满足了一个CRUDer的一切想象，实现灵活，花样繁多。</p><p>有了gorm，就不需要再在代码中维护sql语句了。这值得我们深入学习，而课上所述的更多底层的高级操作，还有待后续课程的学习掌握，本篇文章仅供抛砖引玉，期待更多的大佬一起来学习交流。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文章为自己在基于课程视频时学习Gorm所得心得体会，本人拙见，若有不足之处，还请各位多多指出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-什么是Gorm&quot;&gt;&lt;a href=&quot;#1-什么是Gorm&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Gorm&quot;&gt;&lt;/a&gt;1. 什么是Gorm&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Gorm&lt;/strong&gt;（全称：Go Object Relational Mapping）是一个针对 Go 语言的对象关系映射（ORM）库。ORM 是一种编程技术，用于在关系型数据库和编程语言对象之间建立映射关系，使开发者能够使用面向对象的方式操作数据库，而不必直接编写 SQL 查询语句。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Go 语言入门指南：基础语法和常用特性解析</title>
    <link href="http://example.com/2023/08/11/Go%20%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2023/08/11/Go%20%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90/</id>
    <published>2023-08-11T03:13:33.000Z</published>
    <updated>2025-03-07T07:30:28.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前面的话"><a href="#0-前面的话" class="headerlink" title="0. 前面的话"></a>0. 前面的话</h2><p>本文章为Go语言初学者的帮助教程，旨在帮助读者快速掌握Go编程语言的基础知识和常用特性。</p><p><strong>Go</strong>语言，也被称为<strong>Golang</strong>，是一门由Google开发的现代编程语言，以其简洁、高效和强大的特性受到了广泛的关注和应用。</p><p>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</p><p>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</p><span id="more"></span><h2 id="1-安装和设置"><a href="#1-安装和设置" class="headerlink" title="1. 安装和设置"></a>1. 安装和设置</h2><blockquote><p>在学习Go语言之前，首先需要进行安装和设置，以确保你的开发环境能够正确地支持Go编程。</p></blockquote><ol><li><p><strong>下载Go安装包</strong>：<br>前往Go官方网站（ <a href="https://go.dev/dl/">https://go.dev/dl/</a> ）下载适合自己操作系统的安装包。Go支持多种操作系统，包括Windows、macOS和各种Linux发行版。选择与你操作系统和架构匹配的安装包。</p><p><img src="https://pic1.imgdb.cn/item/67ca9fa1066befcec6e014df.png" alt="1"></p></li><li><p><strong>安装Go</strong>：<br>根据你的操作系统选择的安装包，进行相应的安装步骤。在大多数情况下，只需双击安装包并按照提示进行操作即可完成安装。</p></li><li><p><strong>设置环境变量</strong>：<br>安装完成后，需要设置Go的环境变量，以便在终端或命令行中使用Go命令。在Windows系统中，你需要将Go的安装目录（通常是 <code>C:\Go</code>）添加到系统的 <code>PATH</code> 环境变量中。</p><p>在macOS和Linux系统中，你需要将Go的安装目录添加到你的shell配置文件（如 <code>.bashrc</code> 或 <code>.zshrc</code>）中。设置好环境变量后，你就可以在终端中运行Go命令了。</p></li><li><p><strong>验证安装</strong>：<br>打开终端或命令行，输入 <code>go version</code> 命令，查看Go的版本信息。如果显示了正确的版本号，说明安装成功。</p><p><img src="https://pic1.imgdb.cn/item/67ca9fa2066befcec6e014e1.png" alt="2"></p></li><li><p><strong>创建工作目录</strong>：<br>在开始编写Go代码之前，你可能希望创建一个专门用于存放Go项目的工作目录。在这个目录中，你可以组织你的代码文件、依赖和其他资源。</p></li><li><p><strong>选择代码编辑器或集成开发环境（IDE）</strong>：<br>选择一个适合你的代码编辑器或IDE，以便开始编写Go代码。一些流行的选择包括<a href="https://code.visualstudio.com/Download">Visual Studio Code（VSCode）</a>与<a href="https://www.jetbrains.com/go/">GoLand</a>等。</p></li><li><p><strong>Hello World！</strong>：<br>现在，你已经完成了Go的安装和设置，可以尝试编写你的第一个Go程序了。创建一个新的Go源文件，命名为 <code>hello.go</code>，然后输入以下代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件后，在终端中进入文件所在目录，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>如果看到输出了 “Hello, World!”，那么恭喜你，你已经成功地安装、设置和运行了你的第一个Go程序！</p></li></ol><p>安装和设置是开始学习任何编程语言的第一步，正确地完成这些步骤能够为你的Go编程之旅奠定坚实的基础。在接下来的学习中，你将逐渐了解更多关于Go语言的基础知识和特性。</p><h2 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2. 基础语法"></a>2. 基础语法</h2><h3 id="2-1-包和导入"><a href="#2-1-包和导入" class="headerlink" title="2.1. 包和导入"></a>2.1. 包和导入</h3><ul><li>在Go语言中，其程序由包（Packages）组成，每个文件都属于一个包。</li><li>其中<code>main</code> 包是程序的入口，包含了 <code>main()</code> 函数。</li><li>使用 <code>import</code> 关键字导入其他包。</li></ul><p>在上述的<code>Hello.go</code>的程序中，所导入的<code>fmt</code>包实现了格式化 IO（输入/输出）的函数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-变量和数据类型："><a href="#2-2-变量和数据类型：" class="headerlink" title="2.2. 变量和数据类型："></a>2.2. <strong>变量和数据类型</strong>：</h3><ul><li>使用 <code>var</code> 关键字声明变量，Go会自动推断变量类型。</li><li>基本数据类型包括整型、浮点型、布尔型、字符串等。</li><li>使用 <code>:=</code> 简化变量声明和赋值。</li></ul><p>对于Go语言的变量声明，相比于传统语言的变量声明，Go语言最大的特点是可以选择省略变量类型，编译器可以根据右侧的值自动推断出变量的类型，这极大的方便了我们的开发，同时由于其变量声明有别于其他语言的<strong>变量类型+变量名</strong>，Go语言是相反的，因此省略变量类型的写法也可以方便其他语言的程序员快速上手Go语言。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指明变量类型的变量定义方法</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">19260817</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不指明变量类型的变量定义方法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">19260817</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简化变量定义方法</span></span><br><span class="line">a := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">b := <span class="number">19260817</span></span><br><span class="line">c := <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-3-常量"><a href="#2-3-常量" class="headerlink" title="2.3. 常量"></a>2.3. 常量</h3><ul><li>使用 <code>const</code> 关键字声明常量。</li><li>常量的值在编译时确定，不能被修改。</li></ul><p>Go语言中常量的声明与其他语言不太相同，需要使用<code>const</code>关键字替换<code>var</code>关键字，其他部分与变量相差不大。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">string</span> = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="keyword">const</span> b <span class="type">int</span> = <span class="number">19260817</span></span><br><span class="line"><span class="keyword">const</span> c <span class="type">bool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4. 控制流"></a>2.4. 控制流</h3><ul><li>使用 <code>if</code>、<code>else</code>、<code>switch</code> 进行条件判断。</li><li>使用 <code>for</code> 进行循环，支持 <code>for</code>、<code>while</code>、<code>do-while</code> 三种风格。</li><li><code>break</code> 和 <code>continue</code> 用于循环控制。</li></ul><p>对于分支语句if，Go语言和其他语言类似，唯一不同的是对于判断条件部分不需要用小括号包裹起来。而switch分支语句与其他语言略有不同，在Go语言中，不需要添加break，默认执行对应的case语句后退出。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if-else用法示例</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">7</span> % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Printlen(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printlen(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch用法示例</span></span><br><span class="line">a := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.PrintIn(<span class="string">&quot;one&quot;</span>)  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.PrintIn(<span class="string">&quot;two&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Printin(<span class="string">&quot;three&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>，<span class="number">5</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;four or five&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.PrintIn(<span class="string">&quot;other&quot;</span>)</span><br></pre></td></tr></table></figure><p>而对于循环语句，Go语言中没有其他传统语言中的while循环，但其for循环功能十分强大，支持while循环的书写风格。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统for循环</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while循环风格书写</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-函数"><a href="#2-5-函数" class="headerlink" title="2.5. 函数"></a>2.5. 函数</h3><ul><li>使用 <code>func</code> 关键字定义函数，可以接收参数并返回值。</li><li>支持多返回值。</li><li>函数也可以作为一种类型，用于高阶函数的实现。</li></ul><p>在Go语言中，使用<code>func</code>关键字声明一个函数，函数声明的语法与其他语言略有差异，与基本的变量定义相同，Go语言中，函数的返回类型置于函数名和传递参数之后，需要多加留意。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-复合数据类型"><a href="#3-复合数据类型" class="headerlink" title="3. 复合数据类型"></a>3. 复合数据类型</h2><blockquote><p>在Go语言中，复合数据类型允许你将多个值组合在一起，以创建更为复杂和结构化的数据结构。本部分将介绍Go语言中的几种重要的复合数据类型，包括数组、切片、映射（Map）和结构体（Struct）。</p></blockquote><h3 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1. 数组"></a>3.1. 数组</h3><ul><li>数组是一种固定长度、相同数据类型元素的集合。</li><li>声明数组：<code>var arr [n]T</code>，其中 <code>n</code> 为数组长度，<code>T</code> 为元素类型。</li><li>初始化数组：<code>arr := [n]T&#123;val1, val2, ...&#125;</code>。</li><li>访问数组元素：使用索引访问，索引从 0 开始。</li></ul><p>与多数传统语言一样，Go语言的数组在功能使用上相差不大，唯一注意的是其变量定义遵循Go语言自己的定义风格，即<strong>数据类型后置</strong>。同时，使用<code>len()</code>方法可以获取数组长度。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1123</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">5813</span></span><br><span class="line"></span><br><span class="line">fmt.Println(arr[<span class="number">1</span>], <span class="built_in">len</span>(arr)) <span class="comment">// 5813 2</span></span><br></pre></td></tr></table></figure><h3 id="3-2-切片"><a href="#3-2-切片" class="headerlink" title="3.2. 切片"></a>3.2. 切片</h3><ul><li>切片是动态长度、指向数组的引用，类似于动态数组。</li><li>创建切片：<code>slice := make([]T, length, capacity)</code>，其中<code>length</code> 为初始长度，<code>capacity</code> 为底层数组容量。</li><li>切片操作：可以使用 <code>slice[start:end]</code> 对切片进行切割。</li><li>切片扩容：通过 <code>append</code> 函数将元素添加到切片。</li></ul><p>而对于<strong>切片</strong>，其为Go语言特有的类型，可以类比为动态数组，即声明时不指定大小。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(arr[<span class="number">1</span>], <span class="built_in">len</span>(arr)) <span class="comment">// 1 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//append()追加数据至切片</span></span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">3</span>)</span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">5</span>, <span class="number">8</span>)</span><br><span class="line">fmt.Println(arr)      <span class="comment">// [1 1 2 3 5 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//copy()复制切片</span></span><br><span class="line">arr2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"><span class="built_in">copy</span>(arr2, arr)</span><br><span class="line">fmt.Println(arr2)     <span class="comment">// [1 1 2 3 5 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类似Python的切片语法</span></span><br><span class="line">fmt.Println(arr[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment">// [2 3 5]</span></span><br><span class="line">fmt.Println(arr[:<span class="number">5</span>])  <span class="comment">// [1 1 2 3 5]</span></span><br><span class="line">fmt.Println(arr[<span class="number">2</span>:])  <span class="comment">// [2 3 5 8]</span></span><br></pre></td></tr></table></figure><h3 id="3-3-映射"><a href="#3-3-映射" class="headerlink" title="3.3. 映射"></a>3.3. 映射</h3><ul><li>创建映射：<code>m := make(map[K]V)</code>，其中 <code>K</code> 为键的类型，<code>V</code> 为值的类型。</li><li>插入和访问元素：<code>m[key] = value</code>，<code>value = m[key]</code>。</li><li>删除元素：<code>delete(m, key)</code>。</li></ul><p><strong>Map</strong> 是一种无序的<strong>键值对</strong>的集合，通过 <strong>key</strong> 来快速检索数据。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个初始容量为 10 的 Map</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字面量创建 Map</span></span><br><span class="line">m = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line"><span class="string">&quot;apple&quot;</span> : <span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;banana&quot;</span> : <span class="number">2</span>,</span><br><span class="line"><span class="string">&quot;orange&quot;</span> : <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值对</span></span><br><span class="line">vl := m[<span class="string">&quot;apple&quot;</span>]</span><br><span class="line">v2, ok := m[<span class="string">&quot;pear&quot;</span>]</span><br><span class="line"><span class="comment">// 如果键不存在，ok 的值为 false，v2 的值为该类型的零值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改键值对</span></span><br><span class="line">m[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取map长度</span></span><br><span class="line">len_m := <span class="built_in">len</span>(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;banana&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-4-结构体"><a href="#3-4-结构体" class="headerlink" title="3.4. 结构体"></a>3.4. 结构体</h3><ul><li>声明结构体：<code>type StructName struct &#123; field1 type1; field2 type2; ... &#125;</code>。</li><li>创建结构体实例：<code>instance := StructName &#123; field1: val1, field2: val2, ... &#125;</code>。</li><li>访问结构体字段：使用 <code>instance.field</code>。</li></ul><p>与其他的语言类似，Go语言中的结构体仍然是不同数据类型的字段的集合，用于表示一个更复杂的数据结构，其用法和其他语言相差不大。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">    tilte <span class="type">string</span></span><br><span class="line">    author <span class="type">string</span></span><br><span class="line">    subject <span class="type">string</span></span><br><span class="line">    bookid <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 book1 为 Books 类型</span></span><br><span class="line"><span class="keyword">var</span> book1 Books </span><br><span class="line"></span><br><span class="line"><span class="comment">// book1 各参数赋值</span></span><br><span class="line">book1.title = <span class="string">&quot;Hello, Go!&quot;</span></span><br><span class="line">book1.author = <span class="string">&quot;张三&quot;</span></span><br><span class="line">book1.subject = <span class="string">&quot;IT&quot;</span></span><br><span class="line">book1.bookid = <span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="4-并发编程"><a href="#4-并发编程" class="headerlink" title="4. 并发编程"></a>4. 并发编程</h2><blockquote><p>并发是指在同一时间内处理多个任务的能力，Go语言以其独特的并发模型在编写并发程序时具有明显优势。本部分将深入介绍Go语言中的并发编程，包括Goroutine、通道（Channel）和并发模式等内容。</p></blockquote><h3 id="4-1-Goroutine"><a href="#4-1-Goroutine" class="headerlink" title="4.1. Goroutine"></a>4.1. Goroutine</h3><ul><li>Goroutine 是Go语言的轻量级线程，由Go运行时管理。</li><li>使用关键字 <code>go</code> 启动一个Goroutine，将函数调用包装为并发任务。</li><li>Goroutine 之间共享内存，但通常通过通道进行通信，避免竞态条件。</li></ul><p>Goroutine 是 Go 语言中的轻量级并发执行单元，是其并发模型的核心组成部分。Goroutine 使得在同一个程序中同时执行多个任务变得更加容易和高效，而且在语言层面上提供了内置的支持。</p><p>Goroutine 的创建和销毁开销非常小，相较于操作系统线程来说，创建数千甚至数百万个 Goroutine 是可行的。</p><p>同时，在 Go 程序中，你可以同时启动多个 Goroutine，它们将会并发地执行，不需要手动管理线程池或任务队列。</p><p>以下是一个使用 Goroutine 的简单示例，计算 1 到 10 的阶乘并打印结果：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    result := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        result *= i</span><br><span class="line">    &#125;</span><br><span class="line">    ch &lt;- result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> factorial(i, ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        result := &lt;-ch</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Factorial of %d: %d\n&quot;</span>, i, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 Goroutine，Go 语言能够以高效、简洁的方式实现并发，充分利用多核处理器的能力，从而提升程序性能和响应能力。然而，需要注意正确地处理 Goroutine 之间的同步和通信，以避免竞态条件和数据访问问题。</p><h3 id="4-2-通道（Channel）"><a href="#4-2-通道（Channel）" class="headerlink" title="4.2. 通道（Channel）"></a>4.2. 通道（Channel）</h3><ul><li>通道是Goroutine之间进行通信和同步的机制。</li><li>使用 <code>make</code> 函数创建通道：<code>ch := make(chan T)</code>，<code>T</code> 为通道中传递的数据类型。</li><li>发送数据到通道：<code>ch &lt;- data</code>。发送操作会阻塞，直到通道有足够的空间来存储数据。</li><li>从通道接收数据：<code>data := &lt;-ch</code>。接收操作会阻塞，直到通道中有数据可供接收。</li><li>通道也支持带缓冲的通道：<code>ch := make(chan T, capacity)</code>。</li></ul><p><strong>通道（Channel）</strong>是 Go 语言中用于实现并发安全的数据传递和通信的机制。通道可以在 Goroutine 之间传递数据，并且能够在数据传递的同时进行同步操作，从而有效地避免了竞态条件和其他并发问题。</p><p>默认情况下，通道的发送和接收操作都是阻塞的，直到有一方准备好。</p><p>通过使用 <code>select</code> 语句可以实现非阻塞的通道操作，从而避免 Goroutine 阻塞在通道操作上。</p><p>通道适用于多个 Goroutine 之间的数据传递和同步，比如任务队列、消息传递等场景。</p><p>以下是一个简单的示例，演示了如何使用通道来计算两个数的和：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := a + b</span><br><span class="line">ch &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> add(<span class="number">3</span>, <span class="number">5</span>, ch)</span><br><span class="line">result := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;Result:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-并发模式"><a href="#4-3-并发模式" class="headerlink" title="4.3. 并发模式"></a>4.3. 并发模式</h3><ul><li>基于通道的并发模式：使用通道在Goroutine之间传递数据，实现数据同步和任务协调。</li><li>扇出-扇入模式：将一个输入通道分发到多个处理Goroutine，然后将结果合并到一个输出通道。</li><li>选择器模式：使用 <code>select</code> 语句监听多个通道，响应可读或可写的通道操作。</li><li>互斥锁和条件变量：通过 <code>sync</code> 包实现对共享资源的互斥访问和条件同步。</li><li>工作池模式：工作池维护一组 Goroutine，用于执行特定的任务。</li><li>串行模式：使用通道将多个 Goroutine 串行化，确保它们按顺序执行。</li></ul><p>并发模式是一组在并发编程中常用的设计模式，用于解决在多个并发执行的 Goroutine 之间协调、同步和通信的问题。这些模式帮助开发者编写出更可靠、高效的并发程序，避免竞态条件、死锁和其他并发问题。</p><p>这些并发模式帮助开发者解决了在并发编程中常见的问题，使得并发程序更易于理解、维护和调试。根据不同的应用场景，开发者可以选择合适的模式来组织并发代码，从而充分利用多核处理器的能力，提高程序性能和响应能力。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-前面的话&quot;&gt;&lt;a href=&quot;#0-前面的话&quot; class=&quot;headerlink&quot; title=&quot;0. 前面的话&quot;&gt;&lt;/a&gt;0. 前面的话&lt;/h2&gt;&lt;p&gt;本文章为Go语言初学者的帮助教程，旨在帮助读者快速掌握Go编程语言的基础知识和常用特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Go&lt;/strong&gt;语言，也被称为&lt;strong&gt;Golang&lt;/strong&gt;，是一门由Google开发的现代编程语言，以其简洁、高效和强大的特性受到了广泛的关注和应用。&lt;/p&gt;
&lt;p&gt;Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。&lt;/p&gt;
&lt;p&gt;对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Git的正确使用姿势与最佳实践：团队协作和版本控制的最佳实践</title>
    <link href="http://example.com/2023/08/04/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/08/04/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-08-04T10:16:33.000Z</published>
    <updated>2025-03-07T07:33:19.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-前面的话"><a href="#0-前面的话" class="headerlink" title="0. 前面的话"></a>0. 前面的话</h3><p>&emsp;&emsp;在现代软件开发领域，团队协作和版本控制是构建成功项目不可或缺的两个关键要素。随着软件项目的规模和复杂性不断增长，有效地管理代码、协调多人合作、跟踪变更以及保持项目的稳定性变得愈发重要。而Git作为分布式版本控制系统，为开发人员带来了强大的工具，帮助他们更好地应对这些挑战。</p><p>&emsp;&emsp;本文主要面向初次进行团队开发的成员，旨在探讨Git的正确使用姿势与最佳实践，以便其团队能够更加快速的入手，感受协作开发的高效性，轻松地管理项目的演变过程，并确保项目的质量和稳定性。</p><span id="more"></span><h3 id="1-事先准备"><a href="#1-事先准备" class="headerlink" title="1. 事先准备"></a>1. 事先准备</h3><ul><li><p>Git下载</p><ul><li>官网下载<a href="https://git-scm.com/">Git (git-scm.com)</a>或命令行<code>git update-git-for-windows</code>更新至新版本</li></ul></li><li><p>注册<a href="https://github.com/">GitHub</a>账号</p></li></ul><h3 id="2-克隆代码到本地"><a href="#2-克隆代码到本地" class="headerlink" title="2. 克隆代码到本地"></a>2. 克隆代码到本地</h3><p>&emsp;&emsp;在多人协作的项目搭建中，通常是由项目组长发起项目协作，通过邮件邀请协作对象加入，被邀请者只需通过邮件点击确认加入项目即可。同时将项目内容克隆到本地，即可在本地进行项目的开发。</p><h4 id="2-1-通过邮箱验证加入Github多人协作"><a href="#2-1-通过邮箱验证加入Github多人协作" class="headerlink" title="2.1. 通过邮箱验证加入Github多人协作"></a>2.1. 通过邮箱验证加入Github多人协作</h4><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804174753732.png" alt="image-20230804174753732"></p><h4 id="2-2-获取远程仓库的URL地址"><a href="#2-2-获取远程仓库的URL地址" class="headerlink" title="2.2. 获取远程仓库的URL地址"></a>2.2. 获取远程仓库的URL地址</h4><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804174931968.png" alt="image-20230804174931968"></p><h4 id="2-3-进入项目工程路径下，打开Git"><a href="#2-3-进入项目工程路径下，打开Git" class="headerlink" title="2.3. 进入项目工程路径下，打开Git"></a>2.3. 进入项目工程路径下，打开Git</h4><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804175228864.png" alt="image-20230804175228864"></p><h4 id="2-4-克隆仓库至本地"><a href="#2-4-克隆仓库至本地" class="headerlink" title="2.4. 克隆仓库至本地"></a>2.4. 克隆仓库至本地</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/THGRakid/Reborn-but-in-Go.git</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804175710704.png" alt="image-20230804175710704"></p><h3 id="3-拉取个人分支"><a href="#3-拉取个人分支" class="headerlink" title="3. 拉取个人分支"></a>3. 拉取个人分支</h3><p>&emsp;&emsp;<strong>分支</strong>，顾名思义，是在同一项目在同一时间下的不同版本，项目开发人员可以分工协作开发自己的模块并通过分支更新至版本库。</p><h4 id="3-1-查看项目分支"><a href="#3-1-查看项目分支" class="headerlink" title="3.1. 查看项目分支"></a>3.1. 查看项目分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -a //查看所有分支，包括本地分支和远程分支</span><br><span class="line">git branch -r //查看远程分支</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804185214948.png" alt="image-20230804185214948"></p><h4 id="3-2-本地创建新的分支"><a href="#3-2-本地创建新的分支" class="headerlink" title="3.2. 本地创建新的分支"></a>3.2. 本地创建新的分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b branchname //直接新建一个分支然后切换至新创建的分支，其中branchname为自定义分支名字</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804185557566.png" alt="image-20230804185557566"></p><h4 id="3-3-将新分支推送至GitHub"><a href="#3-3-将新分支推送至GitHub" class="headerlink" title="3.3. 将新分支推送至GitHub"></a>3.3. 将新分支推送至GitHub</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin branchname</span><br></pre></td></tr></table></figure><p>登录验证</p><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804190005937.png" width="500px"/></p><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804191450200.png" alt="image-20230804191450200"></p><p>提交成功后可查看验证</p><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804191648554.png" alt="image-20230804191648554"></p><h3 id="4-关联本地编辑器"><a href="#4-关联本地编辑器" class="headerlink" title="4. 关联本地编辑器"></a>4. 关联本地编辑器</h3><p>&emsp;&emsp;为了便于开发，我们可以将git操作与Goland编辑器关联，从而更好地进行项目的开发。</p><ul><li><p>打开”文件-设置-版本控制“</p><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804192012821.png" alt="image-20230804192012821"></p></li><li><p>配置Git可执行文件路径</p><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804192217028.png" alt="image-20230804192217028"></p></li><li><p>绑定Github账号</p><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804192204958.png" alt="image-20230804192204958"></p></li></ul><h3 id="5-多人协作测试"><a href="#5-多人协作测试" class="headerlink" title="5. 多人协作测试"></a>5. 多人协作测试</h3><p>&emsp;&emsp;至此，基本的多人协作环境的搭建已经完成，对于初学者来说，可以简单通过提交修改<code>readme.md</code>文件，来验证是否能够成功推送分支内容。</p><ul><li><p>打开readme.md文件，添加自己的分工信息</p><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804192451906.png" alt="image-20230804192451906"></p></li><li><p>点击提交，添加提交信息</p><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804192556420.png" alt="image-20230804192556420"></p></li><li><p>可看到自己分支下成功提交内容</p><p><img src="C:\Users\Fine\AppData\Roaming\Typora\typora-user-images\image-20230804194307949.png" alt="image-20230804194307949"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;0-前面的话&quot;&gt;&lt;a href=&quot;#0-前面的话&quot; class=&quot;headerlink&quot; title=&quot;0. 前面的话&quot;&gt;&lt;/a&gt;0. 前面的话&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在现代软件开发领域，团队协作和版本控制是构建成功项目不可或缺的两个关键要素。随着软件项目的规模和复杂性不断增长，有效地管理代码、协调多人合作、跟踪变更以及保持项目的稳定性变得愈发重要。而Git作为分布式版本控制系统，为开发人员带来了强大的工具，帮助他们更好地应对这些挑战。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;本文主要面向初次进行团队开发的成员，旨在探讨Git的正确使用姿势与最佳实践，以便其团队能够更加快速的入手，感受协作开发的高效性，轻松地管理项目的演变过程，并确保项目的质量和稳定性。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
